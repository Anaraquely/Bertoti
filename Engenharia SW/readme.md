
# ATIVIDADE 1 - 11/08/2023

We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

_TRADUÇÃO: Vemos três diferenças críticas entre programação e engenharia de software: tempo, escala e as compensações em jogo. Em um projeto de engenharia de software, os engenheiros precisam se preocupar mais com a passagem do tempo e com a eventual necessidade de mudanças. Em uma organização de engenharia de software, precisamos nos preocupar mais com escala e eficiência, tanto para o software que produzimos quanto para a organização que o está produzindo. Por fim, como engenheiros de software, somos solicitados a tomar decisões mais complexas com resultados de alto risco, muitas vezes com base em estimativas imprecisas de tempo e crescimento._

As três diferenças críticas entre programação e engenharia de software destacadas no texto são:
Tempo: a programação é frequentemente vista como uma atividade de curto prazo, com foco na implementação de requisitos específicos. A engenharia de software, por outro lado, é uma atividade de longo prazo, que exige a consideração da evolução do software ao longo do tempo.
Escala: a programação geralmente envolve a criação de sistemas de software de pequeno a médio porte. A engenharia de software, por outro lado, pode envolver a criação de sistemas de software de grande porte, que precisam ser capazes de lidar com grandes volumes de dados e usuários.
Compensações: a programação muitas vezes se concentra na implementação de uma solução que atende aos requisitos específicos. A engenharia de software, por outro lado, exige a consideração de uma série de fatores, incluindo requisitos, custos, cronogramas e riscos.

# ATIVIDADE 2 - 14/08/2023
  
 Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.
 
_TRADUÇÃO: No Google, às vezes dizemos: “A engenharia de software é a programação integrada ao longo do tempo”. A programação é certamente uma parte significativa da engenharia de software: afinal, a programação é como você gera um novo software em primeiro lugar. Se você aceitar essa distinção, também ficará claro que talvez seja necessário delinear entre tarefas de programação (desenvolvimento) e tarefas de engenharia de software (desenvolvimento, modificação, manutenção). A adição de tempo adiciona uma nova dimensão importante à programação. Cubos não são quadrados, distância não é velocidade. Engenharia de software não é programação._

A programação é certamente uma parte significativa da engenharia de software. Afinal, a programação é como você gera um novo software. No entanto, a programação é apenas uma parte do processo de engenharia de software. A engenharia de software também inclui atividades como análise de requisitos, projeto de arquitetura, gerenciamento de projetos e testes.

TRADE-OFF (3 Exemplos) - Perdas e ganhos:

Qualidade x custo: um produto de alta qualidade geralmente é mais caro do que um produto de baixa qualidade.

Velocidade x precisão: um projeto que é concluído rapidamente geralmente não é tão preciso quanto um projeto que é concluído com mais cuidado.

Eficiência x flexibilidade: um sistema eficiente geralmente não é tão flexível quanto um sistema flexível.

# ATIVIDADE 3 - 18/08/2023
10 Heurísticas de Usabilidade - 1 Erro e 1 Acerto

1 - Visibilidade do status do sistema


![image](https://github.com/Anaraquely/Bertoti/assets/127275110/f317cba7-596b-4993-8365-6521ba6b63ab)

Erro: Mensagem de erro que é muito vaga ou difícil de entender.

![Status do Sistema](https://github.com/Anaraquely/Bertoti/assets/127275110/b929e6aa-4d2f-4ba8-b845-c86382324ce5)

Acerto: Uso de simbolos intuitivos 


2 - Correspondência entre o sistema e o mundo real

Erro: 

Acerto:


3 - Controle e liberdade do usuário

Erro: 

Acerto:


4 - Consistência e padrões

Erro: 

Acerto:


5 - Prevenção de erros

Erro: 

Acerto:


6 - Reconhecimento em vez de lembrança

Erro: 

Acerto:


7 - Flexibilidade e eficiência de uso

Erro: 

Acerto:


8 - Design estético e minimalista

Erro: 

Acerto:


9 - Ajude os usuários a reconhecer, diagnosticar e se recuperar de erros

Erro: 

Acerto:


10 - Ajuda e documentação

Erro: 

Acerto:


# ATIVIDADE 4 - 21/08/2023 - 13/11/2023

Diagrama UML

![Captura de tela 2023-11-30 191126](https://github.com/Anaraquely/Bertoti/assets/127275110/49d1b3a9-dcac-4ec5-914f-23252833fed8)


Diagrama de Classes 

![Imagem do WhatsApp de 2023-11-15 à(s) 19 20 48_4551f028](https://github.com/Anaraquely/Bertoti/assets/127275110/21d94cb7-ff4a-4df2-a371-16aa0bc599ac)



